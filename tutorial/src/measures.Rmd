# Implemented Performance Measures

The following tables show the performance measures available for the different types of
learning problems as well as general performance measures in alphabetical order.
(See also the documentation about [&measures] and [&makeMeasure] for available measures and
their properties.)

Column **Minimize** indicates if the measure is minimized during, e.g., tuning or
feature selection.
**Best** and **Worst** show the best and worst values the performance measure can attain.
For *classification*, column **MultiClass** indicates if a measure is suitable for
multi-class problems. If not, the measure can only be used for binary classification problems.

The next six columns refer to information required to calculate the performance measure.

* **Prediction**: The [&Prediction] object.
* **Truth**: The true values of the response variable(s) (for supervised learning).
* **Probs**: The predicted probabilities (might be needed for classification).
* **Model**: The [WrappedModel](&makeWrappedModel) (e.g., for calculating the training time).
* **Task**: The [&Task] (relevant for cost-sensitive classification).
* **Feats**: The predicted data (relevant for clustering).

**Aggregation** shows the default [aggregation method](&aggregations) tied to the measure.


```{r include=FALSE}
linkFct = function(x, y) {
  collapse(sprintf("[%1$s](http://www.rdocumentation.org/packages/mlr/functions/%2$s)", x, y), sep = "<br />")
}

getTab = function(type) {
  m = list(featperc = featperc, timeboth = timeboth, timepredict = timepredict, timetrain = timetrain)

  if (type == "general") {
    meas = m
  } else {
    meas = listMeasures(type, create = TRUE)
    ord = order(names(meas))
    meas = meas[ord]
    keep = setdiff(names(meas), names(m))
    meas = meas[keep]
  }

  cols = c("Measure", "Note", "Minimize", "Best", "Worst", "MultiClass", "Prediction", "Truth", "Probs", "Model", "Task", "Feats", "Aggregation")
  df = makeDataFrame(nrow = length(meas), ncol = length(cols),
    col.types = c("character", "character", "logical", "numeric", "numeric", "logical", "logical", "logical", "logical", "logical", "logical", "logical", "character"))
  names(df) = cols

  for (i in seq_along(meas)) {
    mea = meas[[i]]
    df[i, 1] = paste0(linkFct(mea$id, "measures"), " - ", mea$name)
    df[i, 2] = mea$note
    df[i, 3] = mea$minimize
    df[i, 4] = mea$best
    df[i, 5] = mea$worst
    df[i, 6] = "classif.multi" %in% mea$properties
    df[i, 7] = "req.pred" %in% mea$properties
    df[i, 8] = "req.truth" %in% mea$properties
    df[i, 9] = "req.prob" %in% mea$properties
    df[i, 10] = "req.model" %in% mea$properties
    df[i, 11] = "req.task" %in% mea$properties
    df[i, 12] = "req.feats" %in% mea$properties
    df[i, 13] = linkFct(mea$aggr$id, "aggregations")
  }

  just = c("left", "left", "center", "right", "right", "center", "center", "center", "center", "center", "center", "center", "left")

  if (type != "classif") {
    ind = cols != "MultiClass"
    df = df[ind]
    just = just[ind]
  }

  logicals = vlapply(df, is.logical)
  df[logicals] = lapply(df[logicals], function(x) ifelse(x, "X", ""))
  pandoc.table(df, style = "rmarkdown", split.tables = Inf, split.cells = Inf,
    justify = just)
}
```

### Classification
```{r echo=FALSE,results="asis"}
getTab("classif")
```

### Regression
```{r echo=FALSE,results="asis"}
getTab("regr")
```

### Survival analysis
```{r echo=FALSE,results="asis"}
getTab("surv")
```

### Cluster analysis
```{r echo=FALSE,results="asis"}
getTab("cluster")
```

### Cost-sensitive classification
```{r echo=FALSE,results="asis"}
getTab("costsens")
```

### General performance measures
```{r echo=FALSE,results="asis"}
getTab("general")
```
