# Creating an Imputation Method

Function [&makeImputeMethod] allows to create your own imputation method.
For this purpose you need to specify a *learn* function that extracts the necessary
information and an *impute* function that does the actual imputation.
The *learn* and *impute* functions both have at least the following arguments:

* ``data`` is a [data frame](&base::data.frame) with missing values in some features.
* ``col`` indicates the feature to be imputed.
* ``target`` indicates the target variable(s) in a supervised learning task.

Let's have a look at function [imputeMean](&imputations).

```{r, include=FALSE}
showFunctionDef = function(fun, name = gsub("^[^:]*:+", "", deparse(substitute(fun)))) {
  l = deparse(fun)
  l[1] = paste(name, l[1], sep = " = ")
  l
}
```
```{r, code=showFunctionDef(imputeMean), eval=FALSE, tidy=TRUE}
```

This calls the unexported [%mlr] function `simpleImpute` which is defined as follows.

```{r, code=showFunctionDef(mlr:::simpleImpute), eval=FALSE, tidy = TRUE, tidy.opts=list(width.cutoff=80)}
```

The *learn* function calculates the mean of the non-missing observations in column ``col``.
The mean is passed via argument ``const`` to the *impute* function that replaces all ``NA's``
in feature ``col``.


Now let's write a new imputation method: 
In case of longitudinal data a frequently used technique is *last observation
carried forward* (LOCF) where missing values are replaced by the most recent observed value.

In the **R** code below the *learn* function determines the last observed value previous to each ``NA`` (``values``)
as well as the corresponding number of consecutive ``NA's`` (``times``).
The *impute* function generates a vector where the entries in ``values`` are replicated
according to ``times`` and replaces the ``NA's`` in feature ``col``.

```{r}
imputeLOCF = function() {
	makeImputeMethod(
	  learn = function(data, target, col) {
	    x = data[[col]]
	    ind = is.na(x)
	    dind = diff(ind)
	    first = which(dind == 1)     # position of the last observed value previous to NA
	    last = which(dind == -1)     # position of the last of potentially several consecutive NA's
	    values = x[first]            # observed value previous to NA
	    times = last - first         # number of consecutive NA's
	    return(list(values = values, times = times))
	  },
	  impute = function(data, target, col, values, times) {
	    x = data[[col]]
	    replace(x, is.na(x), rep(values, times))
	  }
	)
}
```

In the following the missing values in features ``Ozone`` and ``Solar.R`` in the [airquality](&datasets::airquality) data set
are imputed by LOCF.

```{r}
data(airquality)
imp = impute(airquality, cols = list(Ozone = imputeLOCF(), Solar.R = imputeLOCF()),
  dummy.cols = c("Ozone", "Solar.R"))
head(imp$data, 10)
```
