# Visualization

## Generation and plotting functions

[%mlr]'s visualization capabilities rely on

* *generation functions* which generate data for plots and
* *plotting functions* which plot this output using either [%ggplot2] or [%ggvis] (the latter
  being currently experimental).

This separation allows users to easily make custom visualizations by
taking advantage of the generation functions. The only data transformation that is handled inside
plotting functions is reshaping. The reshaped data is also accessible by calling the plotting
functions and then extracting the data from the [&ggplot2::ggplot] object.

The functions are named accordingly.

* Names of generation functions start with `generate` and are followed by a title-case description of
  their `FunctionPurpose`, followed by `Data`: i.e., `generateFunctionPurposeData`.
  These functions output objects of class `FunctionPurposeData`.
* Plotting functions are prefixed by `plot` followed by their purpose, i.e., `plotFunctionPurpose`.

In the example below we create a plot of classifier performance as function of the decision
threshold for the binary classification problem [&sonar.task].
The generation function [&generateThreshVsPerfData] creates an object of class
[ThreshVsPerfData](&generateThreshVsPerfData) which contains the data for the plot in slot
`$data`.

```{r}
lrn = makeLearner("classif.lda", predict.type = "prob")
n = getTaskSize(sonar.task)
mod = train(lrn, task = sonar.task, subset = seq(1, n, by = 2))
pred = predict(mod, task = sonar.task, subset = seq(2, n, by = 2))
d = generateThreshVsPerfData(pred, measures = list(fpr, fnr, mmce))

class(d)

head(d$data)
```

For plotting we can use the built-in [%mlr] function [&plotThreshVsPerf].

```{r, fig.width = 8, fig.height = 4}
plotThreshVsPerf(d)
```

We could also simply use [&generateThreshVsPerfData] and then manually create the plot: in this
case to plot only one measure.

```{r, fig.width = 6, fig.height = 4}
ggplot(d$data, aes(threshold, fpr)) + geom_line()
```

The option to create plots manually is particularly interesting for all who prefer traditional
[%graphics] or [%lattice] plots to [%ggplot2]. Here is a [%lattice] plot.

```{r, fig.width = 8, fig.height = 4}
lattice::xyplot(fpr + fnr + mmce ~ threshold, data = d$data, type = "l", ylab = "performance", outer = TRUE)
```

Let's look at a second example.
Here we use [&plotPartialPrediction] but extract the data from the plot object and use it
to create a traditional [plot](&graphics::plot), additional to the [%ggplot2] plot.

```{r, fig.width = 6, fig.height = 4}
sonar = getTaskData(sonar.task)
pd = generatePartialPredictionData(mod, sonar, "V11")
plt = plotPartialPrediction(pd)
head(plt$data)

plt
```

```{r, fig.width = 6, fig.height = 5}
plot(Probability ~ V11, data = plt$data, type = "b")
```


## Generation functions

After each function referenced, a tutorial page where it is described in more depth is provided.
The corresponding plots are also described therein. Note that some plots, e.g. [&plotTuneMultiCritResult]
are not described here since they lack a generation function.

 - [&generateFilterValuesData]: [Feature Selection](feature_selection.md)
 - [&generateLearningCurveData]: [Learning Curve](learning_curve.md)
 - [&generateThreshVsPerfData]: [Performance](performance.md)
 - [&generateROCRCurvesData]: [ROC Analysis](roc_analysis.md)
 - [&generatePartialPredictionData]: [Partial Prediction Plots](partial_prediction.md)

## ggplot2 plotting functions

 - [&plotFilterValues]
 - [&plotLearningCurve]
 - [&plotThresVsPerf]
 - [&plotROCRCurves]
 - [&plotPartialPrediction]

## ggvis plotting functions

These functions are experimental and are subject to change, though they should work. Most generate
interactive [%shiny] applications, that automatically start and run locally.

 - [&plotFilterValuesGGVIS]
 - [&plotLearningCurveGGVIS]
 - [&plotThreshVsPerfGGVIS]
 - [&plotROCRCurvesGGVIS]
 - [&plotPartialPredictionGGVIS]
